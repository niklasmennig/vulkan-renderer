#version 460 core
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_flags_primitive_culling : enable
#extension GL_GOOGLE_include_directive : enable

#include "common.glsl"
#include "camera.glsl"

#include "random.glsl"
#include "payload.glsl"
layout(location = 0) rayPayloadEXT RayPayload payload;

layout(set = 0, binding = 0) uniform accelerationStructureEXT as;
layout(set = 0, binding = 1) uniform RayGenerationData {
    CameraData camera;
} raygen_data;
layout(set = 0, binding = 2, rgba32f) uniform image2D images[];


vec3 compute_ray_direction(vec2 ndc) {
    vec3 right = raygen_data.camera.right.xyz;
    vec3 up = raygen_data.camera.up.xyz;
    vec3 forward = raygen_data.camera.forward.xyz;

    float fov_x_half = radians(raygen_data.camera.fov_x) / 2.0;

    float aspect_ratio = float(gl_LaunchSizeEXT.y) / float(gl_LaunchSizeEXT.x);
    float fov_y_half = fov_x_half * aspect_ratio;

    vec3 dir = normalize(forward) + ndc.x * abs(tan(fov_x_half)) * normalize(right) + ndc.y * abs(tan(fov_y_half)) * normalize(up);
    return normalize(dir);
}


void main() {
    int frame_samples = 1;
    vec3 sample_sum = vec3(0);
    for (int s = 0; s < frame_samples; s++) {
        uint seed = gl_LaunchIDEXT.x * 313 + gl_LaunchIDEXT.y * 12 + uint(raygen_data.camera.time) * 543 + raygen_data.camera.clear_accumulated * 78 + s * 234;

        vec2 pixel_center = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
        vec2 pixel_offset = vec2(seed_random(seed), seed_random(seed)) - vec2(0.5);

        vec2 ndc = ((pixel_center + pixel_offset) / vec2(gl_LaunchSizeEXT.xy)) * 2 - 1;
        ndc.y *= -1;

        // initialize payload
        vec3 ray_origin = raygen_data.camera.origin.xyz;
        vec3 ray_direction = compute_ray_direction(ndc);

        payload.color = vec3(0);
        payload.contribution = vec3(1);
        payload.depth = 0;
        payload.seed = seed;

        traceRayEXT(
                    as,
                    gl_RayFlagsOpaqueEXT,
                    0xff,
                    0,
                    0,
                    0,
                    ray_origin,
                    epsilon,
                    ray_direction,
                    ray_max,
                    0
                );
        
        sample_sum += payload.color;
    }

    ivec2 img_coord = ivec2(gl_LaunchIDEXT.xy);
    uint sample_count = raygen_data.camera.clear_accumulated;
    vec3 color = clamp(sample_sum / float(frame_samples), vec3(0,0,0), vec3(10,10,10));

    // accumulate color
    vec4 accum_color;
    if (sample_count <= 1) {
        accum_color = vec4(color, 1.0);
        imageStore(images[1], img_coord, accum_color);
    } else {
        accum_color = imageLoad(images[1], img_coord);
        accum_color = (accum_color * sample_count + vec4(color, 1.0)) / (sample_count + 1);
        imageStore(images[1], img_coord, accum_color);
    }

    // output image
    vec3 color_rgb = accum_color.rgb;
    // apply Reinhard TMO
    vec3 color_tonemapped = vec3(color_rgb.r / 1.0 + color_rgb.r, color_rgb.g / 1.0 + color_rgb.g, color_rgb.b / 1.0 + color_rgb.b);
    imageStore(images[0], img_coord, vec4(color_tonemapped, 1.0));

    // instance indices AOV
    uint i = payload.primary_hit_instance;
    vec3 instance_color =  vec3(floor(i/(255*255))/255.0, floor(i/255)/255.0, (mod(i,255))/255.0);
    if (payload.primary_hit_instance == NULL_INSTANCE) instance_color = vec3(1.0);
    imageStore(images[2], img_coord, vec4(instance_color, 1.0));
    vec3 colored_instance_color = vec3(floatConstruct(hash(i)), floatConstruct(hash(hash(i))), floatConstruct(hash(hash(hash(i)))));
    if (payload.primary_hit_instance == NULL_INSTANCE) colored_instance_color = vec3(1.0);
    imageStore(images[3], img_coord, vec4(colored_instance_color, 1.0));

    // albedo AOV
    imageStore(images[4], img_coord, vec4(payload.primary_hit_albedo, 1.0));
}