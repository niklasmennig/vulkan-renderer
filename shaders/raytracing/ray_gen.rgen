#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_flags_primitive_culling : enable
#extension GL_GOOGLE_include_directive : enable

#include "interface.glsl"
#include "common.glsl"
#include "color.glsl"
#include "random.glsl"
#include "payload.glsl"
#include "texture_data.glsl"
#include "mesh_data.glsl"
#include "material.glsl"
#include "ggx.glsl"
#include "lambert.glsl"
#include "mis.glsl"
#include "environment.glsl"
#include "lights.glsl"
#include "restir.glsl"

layout(location = 0) rayPayloadEXT RayPayload payload;
layout(location = 1) rayPayloadEXT bool shadowray_occluded;

layout(set = DESCRIPTOR_SET_FRAMEWORK, binding = DESCRIPTOR_BINDING_ACCELERATION_STRUCTURE) uniform accelerationStructureEXT as;
layout(set = DESCRIPTOR_SET_FRAMEWORK, binding = 1) uniform RayGenerationData {
    CameraData camera;
} raygen_data;
layout(set = DESCRIPTOR_SET_FRAMEWORK, binding = DESCRIPTOR_BINDING_OUTPUT_BUFFERS) buffer OutputBuffer { vec4 color[]; } output_buffers[];
layout(std430, set = DESCRIPTOR_SET_FRAMEWORK, binding = DESCRIPTOR_BINDING_LIGHTS) readonly buffer LightsData {Light[] lights;} lights_data;

layout(std430, push_constant) uniform PConstants {PushConstants constants;} push_constants;

layout(set = DESCRIPTOR_SET_FRAMEWORK, binding = DESCRIPTOR_BINDING_RESTIR_RESERVOIRS) buffer ReSTIRReservoirBuffers {Reservoir reservoirs[];} restir_reservoirs[];


vec3 compute_ray_direction(vec2 ndc) {
    vec3 right = raygen_data.camera.right.xyz;
    vec3 up = raygen_data.camera.up.xyz;
    vec3 forward = raygen_data.camera.forward.xyz;

    float fov_x = radians(raygen_data.camera.fov_x);

    float aspect_ratio = float(gl_LaunchSizeEXT.y) / float(gl_LaunchSizeEXT.x);
    float fov_y = fov_x * aspect_ratio;

    float fov_x_half = fov_x / 2.0;
    float fov_y_half = fov_y / 2.0;

    vec3 dir = normalize(forward) + ndc.x * abs(tan(fov_x_half)) * normalize(right) + ndc.y * abs(tan(fov_y_half)) * normalize(up);
    return normalize(dir);
}

void sample_direct_light(inout uint seed, vec3 position, out LightSample light_sample, out bool occluded) {
    uint light_idx = uint(floor(push_constants.constants.light_count * random_float(seed)));
    Light light = lights_data.lights[light_idx];
    vec3 random_values = vec3(random_float(seed), random_float(seed), random_float(seed));
    light_sample = sample_light(position, random_values, light);
    // LightSample light_sample = sample_environment(random_values, push_constants.constants.environment_cdf_dimensions); 
    vec3 light_dir = light_sample.direction;                   

    // cast shadow ray
    traceRayEXT(
        as,
        gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT,
        0xff,
        1,
        push_constants.constants.sbt_stride,
        1,
        position,
        EPSILON,
        light_dir,
        light_sample.distance - 2 * EPSILON,
        1
    );

    occluded = shadowray_occluded;
}

void main() {
    uint pixel_index = gl_LaunchIDEXT.x + gl_LaunchIDEXT.y * push_constants.constants.image_extent.x;
    uint seed = hash_combine(gl_LaunchIDEXT.x, hash_combine(gl_LaunchIDEXT.y, hash_combine(push_constants.constants.clear_accumulated, uint(push_constants.constants.time))));

    uint max_depth = push_constants.constants.max_depth;
    uint frame_samples = push_constants.constants.frame_samples;
    uint sample_count = push_constants.constants.clear_accumulated;
    
    uint current_reservoir_index = sample_count % 2;
    uint previous_reservoir_index = (current_reservoir_index + 1) % 2;
    clear_reservoir(restir_reservoirs[current_reservoir_index].reservoirs[pixel_index]);

    uint primary_hit_instance = NULL_INSTANCE;
    vec3 primary_hit_position;
    vec2 primary_hit_uv;
    vec3 primary_hit_albedo = vec3(0);
    vec3 primary_hit_normal = vec3(0);
    float primary_hit_roughness = 0;
    float primary_hit_env_cdf = 0;
    float primary_hit_env_conditional = 0;

    vec3 color_sum = vec3(0.0);
    uint depth_sum = 0;
    for (int frame_sample = 0; frame_sample < frame_samples; frame_sample++) {
        


        vec2 pixel_center = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
        vec2 pixel_offset = vec2(random_float(seed), random_float(seed)) - vec2(0.5);
        vec2 ndc = ((pixel_center + pixel_offset) / vec2(gl_LaunchSizeEXT.xy)) * 2 - 1;
        ndc.y *= -1;

        // initialize payload
        vec3 ray_origin = raygen_data.camera.origin.xyz;
        vec3 ray_direction = compute_ray_direction(ndc);

        uint depth = 1;
        vec3 color = vec3(0.0);
        vec3 contribution = vec3(1.0);

        float last_bsdf_pdf = 1.0;

        while (depth <= max_depth) {

            // trace scene for hit information
            traceRayEXT(
                    as,
                    gl_RayFlagsOpaqueEXT,
                    0xff,
                    0,
                    push_constants.constants.sbt_stride,
                    0,
                    ray_origin,
                    EPSILON,
                    ray_direction,
                    RAY_LEN_MAX,
                    0
                );

            if (!payload.hit) {
                // ray missed scene
                restir_reservoirs[current_reservoir_index].reservoirs[pixel_index].y.nee_seed = 0;

                // calculate theta and phi for environment map
                vec2 thetaphi = thetaphi_from_dir(ray_direction);

                // uv coordinates from theta and phi
                float u = thetaphi.y / (2.0 * PI);
                float v = thetaphi.x / PI;

                // query environment map color
                vec3 base_color = sample_texture(0, vec2(u, v)).rgb;

                if (depth == 1) {
                    primary_hit_env_cdf = sample_texture(1, vec2(u,v)).r;
                    primary_hit_env_conditional = sample_texture(2, vec2(u,v)).r;

                    primary_hit_albedo = base_color;
                }

                if ((push_constants.constants.flags & 2) == 2) {
                    color += contribution * base_color;
                }
                break;
                
            } else {
                // ray intersected with scene geometry

                uint instance = payload.hit_instance;
                uint primitive = payload.hit_primitive;
                vec2 barycentrics = payload.hit_barycentrics;

                vec3 position = payload.hit_transform_world * vec4(get_vertex_position(instance, primitive, barycentrics), 1.0);
                vec3 normal = normalize(payload.hit_transform_world * vec4(get_vertex_normal(instance, primitive, barycentrics), 0.0));
                vec3 face_normal = normalize(payload.hit_transform_world * vec4(get_face_normal(instance, primitive), 0.0));
                vec2 uv = get_vertex_uv(instance, primitive, barycentrics);
                vec3 tangent = normalize(payload.hit_transform_world * vec4(get_vertex_tangent(instance, primitive, barycentrics), 0.0));

                vec3 ray_out = normalize(-ray_direction);
                vec3 new_origin = position;

                vec3 bitangent = normalize(cross(normal, tangent));
                mat3 tbn = basis(normal);
                
                //normal mapping
                vec3 normal_tex = sample_texture(payload.hit_instance, uv, TEXTURE_OFFSET_NORMAL).rbg;
                vec3 sampled_normal = (normal_tex - 0.5) * 2.0;
                normal = normalize(tbn * sampled_normal);
                
                // material properties
               Material material = get_material(instance, uv);
                

                // bsdf sampling
                mat3 to_world_space = basis(normal);
                mat3 to_shading_space = inverse(to_world_space);

                vec3 ray_out_local = normalize(to_shading_space * ray_out);
                bool inner_reflection = dot(ray_out, tbn[1]) < -EPSILON;

                vec4 random_values = vec4(random_float(seed), random_float(seed), random_float(seed), random_float(seed));
                BSDFSample bsdf_sample = sample_ggx(ray_out_local, material.base_color, material.opacity, material.metallic, material.fresnel, material.roughness, material.transmission, material.ior, random_values, inner_reflection); 

                vec3 ray_in_local = normalize(bsdf_sample.direction);
                vec3 ray_in = normalize(to_world_space * ray_in_local);

                // primary hit
                if (depth == 1) {
                    // AOV data
                    primary_hit_instance = payload.hit_instance;
                    primary_hit_position = position;
                    primary_hit_uv = uv;
                    primary_hit_albedo = material.base_color;
                    primary_hit_normal = abs(normal);
                    primary_hit_roughness = material.roughness;
                }

                if (bsdf_sample.pdf < EPSILON) {break;}

                if (!bsdf_sample.specular && (push_constants.constants.flags & 1) == 1) {
                    // direct light
                    uint nee_seed = seed;
                    LightSample light_sample;
                    bool occluded;
                    sample_direct_light(seed, position, light_sample, occluded);

                    vec3 light_dir = light_sample.direction;
                    vec3 light_dir_local = to_shading_space * light_dir;
                    
                    // occluded = occluded && (dot(ray_out, face_normal) * dot(ray_out, normal) > 0);
                    float light_pdf = light_sample.pdf * push_constants.constants.light_count;
                    float bsdf_pdf = pdf_ggx(light_dir_local, ray_out_local, material.base_color, material.opacity, material.metallic, material.fresnel, material.roughness, material.transmission, material.ior);
                    if (!occluded && light_sample.pdf > EPSILON && bsdf_pdf > EPSILON) {
                        vec3 bsdf_eval = eval_ggx(light_dir_local, ray_out_local, material.base_color, material.opacity, material.metallic, material.fresnel, material.roughness, material.transmission, material.ior);  
                        float mis = balance_heuristic(1.0f, light_pdf, 1.0f, bsdf_pdf); 
                        // float mis = 1.0;                     
                        color += mis * bsdf_eval * contribution * (light_sample.intensity) * abs(dot(light_dir, normal));

                        if (depth == 1) {
                            update_reservoir(restir_reservoirs[current_reservoir_index].reservoirs[pixel_index], nee_seed, 1, seed);
                        }
                    } else {
                        restir_reservoirs[current_reservoir_index].reservoirs[pixel_index].sum_weights = 0;
                    }
                }

                contribution *= bsdf_sample.contribution * abs(dot(ray_in, normal)) / bsdf_sample.pdf;
                

                // material emission
                if ((push_constants.constants.flags & 2) == 2) {
                    MaterialParameters material_parameters = get_material_parameters(instance);
                    vec3 intensity =  (sample_texture(payload.hit_instance, uv, TEXTURE_OFFSET_EMISSIVE).rgb * material_parameters.emissive) * material_parameters.emission_strength;
                    float mis_weight = 1.0;
                    if (depth > 1) {
                        float pdf_nee = pdf_area_light(payload.hit_instance, payload.hit_primitive, payload.hit_transform_world);
                        mis_weight = balance_heuristic(1.0, pdf_nee, 1.0, last_bsdf_pdf);
                    }
                    color += mis_weight * intensity * contribution;
                }

                
                ray_origin = ray_origin + ray_direction * payload.hit_t;
                ray_direction = ray_in;

                last_bsdf_pdf = bsdf_sample.pdf;

            }

            // russian roulette
            if (depth > 3 ) {
                float rr_probability = luminance(contribution);
                if (random_float(seed) > rr_probability) {
                    break;
                }
                contribution /= rr_probability;
            }

            depth += 1;
        }

        color_sum += color;
        depth_sum += depth;
    }

    // Reservoir reuse
    if (primary_hit_instance != NULL_INSTANCE) {
        // temporal reuse
        combine_reservoirs(restir_reservoirs[current_reservoir_index].reservoirs[pixel_index], restir_reservoirs[previous_reservoir_index].reservoirs[pixel_index], seed);

        // ReSTIR NEE pass
        uint nee_seed = restir_reservoirs[current_reservoir_index].reservoirs[pixel_index].y.nee_seed;
        LightSample restir_light_sample;
        bool restir_occluded;
        sample_direct_light(nee_seed, primary_hit_position, restir_light_sample, restir_occluded);
        if (!restir_occluded) {
            Material material = get_material(primary_hit_instance, primary_hit_uv);
            mat3 to_local = inverse(basis(primary_hit_normal));
            vec3 local_light_dir = to_local * restir_light_sample.direction;
            vec3 bsdf_eval = eval_ggx(local_light_dir, reflect(local_light_dir, primary_hit_normal), material.base_color, material.opacity, material.metallic, material.fresnel, material.roughness, material.transmission, material.ior);
            color_sum += bsdf_eval * restir_light_sample.intensity * abs(dot(restir_light_sample.direction, primary_hit_normal));
            frame_samples += 1;
        }
    }


    // accumulate color
    vec3 frame_color = color_sum / frame_samples;
    
    vec3 accum_color;
    if (sample_count <= 1) {
        accum_color = frame_color;
        output_buffers[1].color[pixel_index] = vec4(accum_color, 1.0);
    } else {
        accum_color = (output_buffers[1].color[pixel_index].rgb + frame_color);
        output_buffers[1].color[pixel_index] = vec4(accum_color, 1.0);
    }

    // output image
    vec3 color_rgb = accum_color / (sample_count);
    // color_rgb *= pow(2, push_constants.constants.exposure);
    // // apply extended Reinhard TMO
    // float white_point = 1.0;
    // vec3 color_xyY = rgb_to_xyY(color_rgb);
    // float l = color_xyY.b;
    // float l_tonemapped = (l * (1.0 + l * pow(white_point, 2.0))) / (1.0 + l);
    
    // color_rgb = xyY_to_rgb(vec3(color_xyY.x, color_xyY.y, l_tonemapped));

    output_buffers[0].color[pixel_index] = vec4(color_rgb, 1.0);

    if (sample_count == 1) {
        // instance indices AOV
        vec3 instance_color =  vec3(floor(primary_hit_instance/(255*255)), floor(primary_hit_instance/255), (mod(primary_hit_instance,255)));
        if (primary_hit_instance == NULL_INSTANCE) instance_color = vec3(1.0);
        output_buffers[2].color[pixel_index] = vec4(instance_color, 1.0);
        uint color_seed = primary_hit_instance;
        vec3 colored_instance_color = vec3(random_float(color_seed), random_float(color_seed), random_float(color_seed));
        if (primary_hit_instance == NULL_INSTANCE) colored_instance_color = vec3(1.0);
        output_buffers[3].color[pixel_index] = vec4(colored_instance_color, 1.0);

        // albedo AOV
        output_buffers[4].color[pixel_index] = vec4(primary_hit_albedo, 1.0);
        // normal AOV
        output_buffers[5].color[pixel_index] = vec4(primary_hit_normal, 1.0);
        // roughness AOV
        output_buffers[6].color[pixel_index] = vec4(vec3(primary_hit_roughness), 1.0);
        // ray depth AOV
        // output_buffers[7].color[pixel_index] = vec4(float(depth_sum) / frame_samples / max_depth);
        // environment map AOVs
        output_buffers[8].color[pixel_index] = vec4(float(primary_hit_env_cdf));
        output_buffers[9].color[pixel_index] = vec4(float(primary_hit_env_conditional));
    }

    output_buffers[7].color[pixel_index] = vec4(float(restir_reservoirs[current_reservoir_index].reservoirs[pixel_index].y.nee_seed) / 1000.0, 0.0, 0.0, 1.0);

}