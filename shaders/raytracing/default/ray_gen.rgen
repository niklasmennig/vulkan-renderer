#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable
#extension GL_EXT_ray_flags_primitive_culling : enable
#extension GL_GOOGLE_include_directive : enable

#include "payload.glsl"
#include "../../common.glsl"
#include "../../push_constants.glsl"
#include "../../random.glsl"
#include "../interface.glsl"
#include "../lights.glsl"
#include "../environment.glsl"
#include "../bsdf.glsl"
#include "../restir.glsl"
#include "../environment.glsl"
#include "../output.glsl"

layout(location = 0) rayPayloadEXT RayPayload payload;

layout(set = DESCRIPTOR_SET_FRAMEWORK, binding = DESCRIPTOR_BINDING_ACCELERATION_STRUCTURE) uniform accelerationStructureEXT as;

layout(set = DESCRIPTOR_SET_CUSTOM, binding = DESCRIPTOR_BINDING_PREVIOUS_CAMERA_MATRIX) uniform CameraMatrixBuffer {mat4 matrix; vec4 position;} previous_camera_matrix;

vec3 compute_ray_direction(vec2 ndc) {
    // homogeneous pixel coordinates
    vec4 hpc = vec4(ndc, -1, 1);

    vec4 transformed = get_push_constants().inv_camera_matrix * hpc;

    return normalize(transformed.xyz);
}

void main() {
    PushConstants constants = get_push_constants();

    uint sample_count = constants.sample_count;
    uint pixel_index = pixel_to_index(uvec2(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y));

    payload.seed = hash_combine(gl_LaunchIDEXT.x, hash_combine(gl_LaunchIDEXT.y, hash_combine(sample_count, hash_combine(constants.frame, hash_init))));
    payload.pixel_index = pixel_index;

    vec3 ray_origin = constants.camera_position.xyz;
    vec3 ray_direction;

    vec3 multisample_color = vec3(0.0);

    for (uint frame_sample = 0; frame_sample < constants.frame_samples; frame_sample++) {

        // vec2 pixel_center = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
        // vec2 pixel_offset = vec2(random_float(payload.seed), random_float(payload.seed)) - vec2(0.5);
        // if (frame_sample == 0) pixel_offset *= 0;
        vec2 ndc = pixel_to_ndc(gl_LaunchIDEXT.xy);
        ndc.y *= -1;

        // initialize payload
        ray_direction = compute_ray_direction(ndc);

        payload.color = vec3(0.0);
        payload.depth = 1;

        payload.origin = ray_origin;
        payload.direction = ray_direction;

        payload.contribution = vec3(1.0);
        payload.last_bsdf_pdf_inv = 0.0;


        traceRayEXT(
                as,
                0,
                0xff,
                0,
                constants.sbt_stride,
                0,
                payload.origin,
                EPSILON,
                payload.direction,
                RAY_LEN_MAX,
                0
            );

        multisample_color += payload.color;
    }

    vec3 multisample_color_normalized = multisample_color / constants.frame_samples;

    vec3 accumulated_color = output_buffers[OUTPUT_BUFFER_ACCUMULATED].color[pixel_index].rgb;
    if (sample_count == 1) {
        accumulated_color = multisample_color_normalized;
    } else {
        accumulated_color += multisample_color_normalized;
    }

    write_output(OUTPUT_BUFFER_ACCUMULATED, pixel_index, vec4(accumulated_color, 1.0));

    write_output(OUTPUT_BUFFER_RESULT, pixel_index, vec4(accumulated_color / sample_count * pow(2, constants.exposure), 1.0));

    write_output(OUTPUT_BUFFER_RAY_DEPTH, pixel_index, vec4(vec3(float(payload.depth) / constants.max_depth), 1.0));
}