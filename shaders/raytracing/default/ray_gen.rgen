#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable
#extension GL_EXT_ray_flags_primitive_culling : enable
#extension GL_GOOGLE_include_directive : enable

#include "../common.glsl"
#include "../interface.glsl"
#include "payload.glsl"
#include "../random.glsl"
#include "../lights.glsl"
#include "../environment.glsl"
#include "../bsdf.glsl"
#include "../restir.glsl"
#include "../environment.glsl"

layout(location = 0) rayPayloadEXT RayPayload payload;

layout(set = DESCRIPTOR_SET_FRAMEWORK, binding = DESCRIPTOR_BINDING_ACCELERATION_STRUCTURE) uniform accelerationStructureEXT as;
layout(set = DESCRIPTOR_SET_FRAMEWORK, binding = 1) uniform RayGenerationData {
    CameraData camera;
} raygen_data;
layout(set = DESCRIPTOR_SET_FRAMEWORK, binding = DESCRIPTOR_BINDING_OUTPUT_BUFFERS) buffer OutputBuffer { vec4 color[]; } output_buffers[];
layout(std430, set = DESCRIPTOR_SET_FRAMEWORK, binding = DESCRIPTOR_BINDING_LIGHTS) readonly buffer LightsData {Light[] lights;} lights_data;

layout(std430, push_constant) uniform PConstants {PushConstants constants;} push_constants;

layout(std430, set = DESCRIPTOR_SET_FRAMEWORK, binding = DESCRIPTOR_BINDING_RESTIR_RESERVOIRS) buffer ReSTIRReservoirBuffers {Reservoir reservoirs[];} restir_reservoirs[];

vec3 compute_ray_direction(vec2 ndc) {
    vec3 right = raygen_data.camera.right.xyz;
    vec3 up = raygen_data.camera.up.xyz;
    vec3 forward = raygen_data.camera.forward.xyz;

    float fov_x = radians(raygen_data.camera.fov_x);

    float aspect_ratio = float(gl_LaunchSizeEXT.y) / float(gl_LaunchSizeEXT.x);
    float fov_y = fov_x * aspect_ratio;

    float fov_x_half = fov_x / 2.0;
    float fov_y_half = fov_y / 2.0;

    vec3 dir = normalize(forward) + ndc.x * abs(tan(fov_x_half)) * normalize(right) + ndc.y * abs(tan(fov_y_half)) * normalize(up);
    return normalize(dir);
}

LightSample sample_direct_light(inout uint seed, vec3 position) {
    LightSample light_sample;
    if (push_constants.constants.light_count > 0) {
        if (random_float(seed) < 0.5) {
            uint light_idx = uint(floor(push_constants.constants.light_count * random_float(seed)));
            Light light = lights_data.lights[light_idx];
            light_sample = sample_light(position, seed, light);
            light_sample.weight *= push_constants.constants.light_count;
        } else {
            light_sample = sample_environment(seed, push_constants.constants.environment_cdf_dimensions);
        }
        light_sample.weight *= 2.0;
    } else {
        light_sample = sample_environment(seed, push_constants.constants.environment_cdf_dimensions);
    }
    return light_sample;
}


void main() {
    uint sample_count = push_constants.constants.clear_accumulated;
    uint pixel_index = gl_LaunchIDEXT.x + gl_LaunchIDEXT.y * push_constants.constants.image_extent.x;

    uint restir_index = sample_count % 2;
    uint restir_index_previous = (restir_index + 1) % 2;

    payload.pixel_index = pixel_index;
    payload.restir_index = restir_index;

    vec3 ray_origin = raygen_data.camera.origin.xyz;
    vec3 ray_direction;

    vec3 multisample_color = vec3(0.0);

    for (uint frame_sample = 0; frame_sample < push_constants.constants.frame_samples; frame_sample++) {
        uint seed = hash_combine(gl_LaunchIDEXT.x, hash_combine(gl_LaunchIDEXT.y, hash_combine(sample_count, frame_sample)));

        vec2 pixel_center = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
        vec2 pixel_offset = vec2(random_float(seed), random_float(seed)) - vec2(0.5);
        vec2 ndc = ((pixel_center + pixel_offset) / vec2(gl_LaunchSizeEXT.xy)) * 2 - 1;
        ndc.y *= -1;

        // initialize payload
        ray_direction = compute_ray_direction(ndc);

        payload.color = vec3(0.0);
        payload.depth = 1;

        payload.origin = ray_origin;
        payload.direction = ray_direction;

        payload.contribution = vec3(1.0);
        payload.last_bsdf_pdf_inv = 0.0;

        payload.seed = seed;

        traceRayEXT(
                as,
                0,
                0xff,
                0,
                push_constants.constants.sbt_stride,
                0,
                payload.origin,
                EPSILON,
                payload.direction,
                RAY_LEN_MAX,
                0
            );

        multisample_color += max(payload.color, vec3(0.0));
    }

    vec3 multisample_color_normalized = multisample_color / push_constants.constants.frame_samples;

    // RESTIR
    {
        // initial restir samples
        Reservoir current_reservoir = restir_reservoirs[restir_index].reservoirs[pixel_index];
        clear_reservoir(current_reservoir);

        for (uint restir_sample = 0; restir_sample < 8; restir_sample++) {
            const uint restir_seed = hash_combine(payload.seed, 0xdeadbeef);
            uint current_seed = restir_seed;
            LightSample light_sample = sample_direct_light(current_seed, payload.primary_hit_position);
            float p_hat = restir_phat(light_sample, payload.primary_hit_normal);
            update_reservoir(current_reservoir, restir_seed, p_hat, payload.seed);
        }


        uint restir_seed = current_reservoir.sample_seed;
        LightSample restir_sample = sample_direct_light(restir_seed, payload.primary_hit_position);
        current_reservoir.weight = 1.0 / restir_phat(restir_sample, payload.primary_hit_normal) * (1.0 / current_reservoir.num_samples * current_reservoir.sum_weights);
        restir_reservoirs[restir_index].reservoirs[pixel_index] = current_reservoir;

        // temporal reuse
        Reservoir temporal_reservoir;
        clear_reservoir(temporal_reservoir);

        // update with current sample
        uint current_seed = current_reservoir.sample_seed;
        LightSample current_sample = sample_direct_light(current_seed, payload.primary_hit_position);
        float p_hat = restir_phat(current_sample, payload.primary_hit_normal);
        update_reservoir(temporal_reservoir, current_seed, p_hat * current_reservoir.weight * current_reservoir.num_samples, payload.seed);

        // update with previous sample
        Reservoir previous_reservoir = restir_reservoirs[restir_index_previous].reservoirs[pixel_index];
        uint previous_seed = previous_reservoir.sample_seed;
        LightSample previous_sample = sample_direct_light(previous_seed, payload.primary_hit_position);
        float p_hat_previous = restir_phat(previous_sample, payload.primary_hit_normal);
        update_reservoir(temporal_reservoir, previous_seed, p_hat_previous * previous_reservoir.weight * previous_reservoir.num_samples, payload.seed);

        temporal_reservoir.num_samples = current_reservoir.num_samples + previous_reservoir.num_samples;

        uint temporal_seed = temporal_reservoir.sample_seed;
        LightSample temporal_sample = sample_direct_light(temporal_seed, payload.primary_hit_position);
        temporal_reservoir.weight = 1.0 / restir_phat(temporal_sample, payload.primary_hit_normal) * (1.0 / temporal_reservoir.num_samples * temporal_reservoir.sum_weights);

        // use combined sample
        restir_reservoirs[restir_index].reservoirs[pixel_index] = temporal_reservoir;
    }

    // ReSTIR contribution
    if (payload.primary_hit_instance != NULL_INSTANCE && (push_constants.constants.flags & ENABLE_RESTIR) == ENABLE_RESTIR) {
        Material material = get_material(payload.primary_hit_instance, payload.primary_hit_uv);

        uint nee_seed =  restir_reservoirs[restir_index].reservoirs[pixel_index].sample_seed;
        LightSample light_sample = sample_direct_light(nee_seed, payload.primary_hit_position);

        rayQueryEXT ray_query;
        rayQueryInitializeEXT(ray_query, as, gl_RayFlagsTerminateOnFirstHitEXT, 0xff, payload.primary_hit_position, EPSILON, light_sample.direction, light_sample.distance - 2.0 * EPSILON);
        rayQueryProceedEXT(ray_query);

        if (rayQueryGetIntersectionTypeEXT(ray_query, true) == gl_RayQueryCommittedIntersectionNoneEXT) {
            mat3x3 shading_space = transpose(basis(payload.primary_hit_normal));

            vec3 ray_dir_local = shading_space * ray_direction;
            vec3 light_dir_local = shading_space * -light_sample.direction;

            vec3 bsdf_eval = eval_bsdf(ray_dir_local, light_dir_local, material);

            vec3 restir_nee_contribution = bsdf_eval * (light_sample.weight) * abs(dot(light_sample.direction, payload.primary_hit_normal)) * restir_reservoirs[restir_index].reservoirs[pixel_index].weight;

            multisample_color_normalized = multisample_color_normalized + restir_nee_contribution;
        }
    } else {
        Reservoir r = restir_reservoirs[restir_index].reservoirs[pixel_index];
        clear_reservoir(r);
        restir_reservoirs[restir_index].reservoirs[pixel_index] = r;
    }

    multisample_color_normalized = max(multisample_color_normalized, vec3(0.0));

    vec3 accumulated_color = output_buffers[OUTPUT_IMAGE_ACCUMULATED].color[pixel_index].rgb;
    if (sample_count == 1) {
        accumulated_color = multisample_color_normalized;
    } else {
        accumulated_color += multisample_color_normalized;
    }
    output_buffers[OUTPUT_IMAGE_ACCUMULATED].color[pixel_index] = vec4(accumulated_color, 1.0);

    output_buffers[OUTPUT_IMAGE_RESULT].color[pixel_index] = vec4(accumulated_color / sample_count * pow(2, push_constants.constants.exposure), 1.0);

    output_buffers[OUTPUT_IMAGE_ALBEDO].color[pixel_index] = vec4(payload.primary_hit_albedo, 1.0);
    output_buffers[OUTPUT_IMAGE_NORMAL].color[pixel_index] = vec4(payload.primary_hit_normal, 1.0);
    output_buffers[OUTPUT_IMAGE_ROUGHNESS].color[pixel_index] = vec4(vec3(payload.primary_hit_roughness), 1.0);

    uint instance = payload.primary_hit_instance;
    if (instance != NULL_INSTANCE) {
        vec3 instance_color = vec3(float(uint(float(instance) / (255.0 * 255.0)) % 255) / 255.0, float(uint(float(instance) / 255.0) % 255) / 255.0, float(instance % 255) / 255.0);
        output_buffers[OUTPUT_IMAGE_INSTANCE].color[pixel_index] = vec4(instance_color, 1.0);
        output_buffers[OUTPUT_IMAGE_INSTANCE_COLOR].color[pixel_index] = vec4(random_vec3(instance), 1.0);
    } else {
        output_buffers[OUTPUT_IMAGE_INSTANCE].color[pixel_index] = vec4(0.0, 0.0, 0.0, 1.0);
        output_buffers[OUTPUT_IMAGE_INSTANCE_COLOR].color[pixel_index] = vec4(0.0, 0.0, 0.0, 1.0);
    }

    output_buffers[OUTPUT_IMAGE_ENVIRONMENT_CDF].color[pixel_index] = vec4(vec3(payload.environment_cdf), 1.0);
    // output_buffers[OUTPUT_IMAGE_ENVIRONMENT_CDF].color[pixel_index] = vec4(pdf_environment(payload.direction, push_constants.constants.environment_cdf_dimensions));

    output_buffers[OUTPUT_IMAGE_ENVIRONMENT_CONDITIONAL].color[pixel_index] = vec4(vec3(payload.environment_conditional), 1.0);

    output_buffers[OUTPUT_IMAGE_RAY_DEPTH].color[pixel_index] = vec4(vec3(float(payload.depth) / push_constants.constants.max_depth), 1.0);
}