#version 460 core
#extension GL_EXT_ray_tracing : enable

struct CameraData
{
    vec4 origin;
    vec4 forward;
    vec4 right;
    vec4 up;
    float fov_x;
};

struct RayPayload
{
    vec3 next_origin;
    vec3 next_direction;
    vec3 direct_light;
    bool shadow_miss;
    float next_reflection_factor;
};
layout(location = 0) rayPayloadEXT RayPayload payload;
layout(set = 0, binding = 0, rgba32f) uniform image2D img;
layout(set = 0, binding = 1) uniform accelerationStructureEXT as;
layout(set = 0, binding = 2) uniform RayGenerationData {
    CameraData camera;
} raygen_data;


vec3 compute_ray_direction(vec2 ndc) {
    vec3 right = raygen_data.camera.right.xyz;
    vec3 up = raygen_data.camera.up.xyz;
    vec3 forward = raygen_data.camera.forward.xyz;

    float fov_x_half = radians(raygen_data.camera.fov_x) / 2.0;

    float aspect_ratio = float(gl_LaunchSizeEXT.y) / float(gl_LaunchSizeEXT.x);
    float fov_y_half = fov_x_half * aspect_ratio;

    vec3 dir = normalize(forward) + ndc.x * abs(tan(fov_x_half)) * normalize(right) + ndc.y * abs(tan(fov_y_half)) * normalize(up);
    return normalize(dir);
}

void main() {
    float ndc_x = (float(gl_LaunchIDEXT.x) / float(gl_LaunchSizeEXT.x) - 0.5) * 2.0;
    float ndc_y = (float(gl_LaunchIDEXT.y) / float(gl_LaunchSizeEXT.y) - 0.5) * 2.0;
    vec2 ndc = vec2(ndc_x, -ndc_y);

    int max_iterations = 10;
    int iteration = 0;

    // initialize path
    vec3 color = vec3(0.0, 0.0, 0.0);
    float contribution = 1.0;

    // initialize payload
    payload.next_origin = raygen_data.camera.origin.xyz;
    payload.next_direction = compute_ray_direction(ndc);

    while (iteration < max_iterations && length(payload.next_direction) > 0.1 && contribution > 0.001) {
        traceRayEXT(
            as,
            gl_RayFlagsOpaqueEXT,
            0xff,
            0,
            0,
            0,
            payload.next_origin,
            0.001,
            payload.next_direction,
            10000.0,
            0
        );

        color += payload.direct_light * contribution;
        contribution *= payload.next_reflection_factor;
        iteration++;
    }

    imageStore(img, ivec2(gl_LaunchIDEXT.xy), vec4(color, 1.0));
}