#version 460
#extension GL_EXT_ray_query : enable

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "interface.glsl"
#include "../structs.glsl"
#include "../random.glsl"
#include "../push_constants.glsl"
#include "../common.glsl"

layout(set=DESCRIPTOR_SET_BUFFERS, binding = 0) buffer ImageBuffer {vec4[] data;} image_buffer;
layout(set=DESCRIPTOR_SET_BUFFERS, binding = 1) buffer AOVBuffer {vec4[] data;} aov_buffers[4];
layout(set=DESCRIPTOR_SET_BUFFERS, binding = 2) buffer RestirBuffer {Reservoir [] reservoirs;} restir_reservoirs[2];

layout(std430, set = DESCRIPTOR_SET_BUFFERS, binding = 3) readonly buffer LightsData {Light[] lights;} lights_data;

layout(set = DESCRIPTOR_SET_BUFFERS, binding = 4) readonly buffer IndexData {uint data[];} indices;
layout(set = DESCRIPTOR_SET_BUFFERS, binding = 5) readonly buffer VertexData {vec4 data[];} vertices;
layout(set = DESCRIPTOR_SET_BUFFERS, binding = 6) readonly buffer NormalData {vec4 data[];} normals;
layout(set = DESCRIPTOR_SET_BUFFERS, binding = 7) readonly buffer TexcoordData {vec2 data[];} texcoords;
layout(set = DESCRIPTOR_SET_BUFFERS, binding = 8) readonly buffer TangentData {vec4 data[];} tangents;
layout(set = DESCRIPTOR_SET_BUFFERS, binding = 9) readonly buffer OffsetData {uint data[];} mesh_data_offsets;
layout(set = DESCRIPTOR_SET_BUFFERS, binding = 10) readonly buffer OffsetIndexData {uint data[];} mesh_offset_indices;

layout(set = DESCRIPTOR_SET_IMAGES, binding = 0) uniform sampler2D textures[128];
layout(set = DESCRIPTOR_SET_BUFFERS, binding = 11) readonly buffer TextureIndexData {uint data[];} texture_indices;

layout(std430, set = DESCRIPTOR_SET_BUFFERS, binding = 12) readonly buffer MaterialParameterData {MaterialParameters[] data;} material_parameters;

layout(set = DESCRIPTOR_SET_BUFFERS, binding = 13) readonly buffer CameraDataBuffer {mat4 matrix; vec4 position;} previous_camera_data;

layout(set = DESCRIPTOR_SET_ACCELERATION_STRUCTURES, binding = 0) uniform accelerationStructureEXT as;

#define NO_LAYOUT
#include "../raytracing/mesh_data.glsl"
#include "../raytracing/texture_data.glsl"
#include "../raytracing/lights.glsl"
#include "../raytracing/bsdf.glsl"


// reservoirs are continuously resampled and updated to find good NEE paths to reproduce
float restir_p_hat(uint pixel_index, uint seed) {
    vec3 position = aov_buffers[1].data[pixel_index].xyz;
    vec3 normal = aov_buffers[2].data[pixel_index].xyz;
    LightSample light_sample = sample_direct_light(seed, position);
    // return luminance(light_sample.weight) * abs(dot(light_sample.direction, normal));
    return length(light_sample.weight);
}

void update_reservoir(inout Reservoir r, uint sample_seed, float weight, uint seed) {
    r.sum_weights = r.sum_weights + weight;
    r.num_samples = r.num_samples + 1;
    if (random_float(seed) < weight / r.sum_weights) {
        r.sample_seed = sample_seed;
    }
}

void clear_reservoir(inout Reservoir r) {
    r.sum_weights = 0.0;
    r.num_samples = 0;
    r.sample_seed = 0;
    r.weight = 0.0;
}

Reservoir combine_reservoirs(uint pixel_index, Reservoir r0, Reservoir r1, uint seed) {
    Reservoir s;
    clear_reservoir(s);

    update_reservoir(s, r0.sample_seed, restir_p_hat(pixel_index, r0.sample_seed) * r0.weight * r0.num_samples, random_uint(seed));
    update_reservoir(s, r1.sample_seed, restir_p_hat(pixel_index, r1.sample_seed) * r1.weight * r1.num_samples, random_uint(seed));

    s.num_samples = r0.num_samples + r1.num_samples;
    s.weight = (1.0 / restir_p_hat(pixel_index, s.sample_seed)) * (s.sum_weights / s.num_samples);

    return s;
}

void main() {
    PushConstants constants = get_push_constants();

    uint seed = hash_combine(gl_GlobalInvocationID.x, hash_combine(gl_GlobalInvocationID.y, hash_combine(constants.frame, hash_init)));

    uint restir_index = constants.frame % 2;
    uint restir_index_previous = (restir_index + 1) % 2;

    uint pixel_index = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * constants.render_extent.x;
    
    uint hit_instance = decode_uint(aov_buffers[0].data[pixel_index].xyz);
    vec3 hit_position = aov_buffers[1].data[pixel_index].xyz;
    vec3 hit_normal = aov_buffers[2].data[pixel_index].xyz;
    vec2 hit_uv = aov_buffers[3].data[pixel_index].xy;
    // RESTIR
    {
        Reservoir current_reservoir = restir_reservoirs[restir_index].reservoirs[pixel_index];
        clear_reservoir(current_reservoir);

        // initial restir sample generation
        for (uint restir_sample = 0; restir_sample < 8; restir_sample++) {
            uint restir_seed = hash_combine(random_uint(seed), restir_sample);
            float p_hat = restir_p_hat(pixel_index, restir_seed);
            uint update_seed = random_uint(seed);
            update_reservoir(current_reservoir, restir_seed, p_hat, update_seed);
        }

        uint restir_seed = current_reservoir.sample_seed;
        current_reservoir.weight = (1.0 / restir_p_hat(pixel_index, restir_seed)) * (current_reservoir.sum_weights / current_reservoir.num_samples);


        // evaluate visibility of initial samples
        uint initial_seed =  current_reservoir.sample_seed;
        LightSample light_sample = sample_direct_light(initial_seed, hit_position);
        rayQueryEXT ray_query;
        rayQueryInitializeEXT(ray_query, as, gl_RayFlagsTerminateOnFirstHitEXT, 0xff, hit_position, EPSILON, light_sample.direction, light_sample.distance - 2.0 * EPSILON);
        rayQueryProceedEXT(ray_query);
        if (rayQueryGetIntersectionTypeEXT(ray_query, true) != gl_RayQueryCommittedIntersectionNoneEXT) {
            current_reservoir.weight = 0;
        }

        // temporal reuse
        vec3 hit_direction = normalize(hit_position - previous_camera_data.position.xyz);
        // vec4 hit_direction_ortho = vec4(hit_direction, 0.0);
        // vec3 center_direction = compute_ray_direction(vec2(0,0));
        // float proj = dot(hit_direction, center_direction);
        vec4 prev_pixel_homo = (previous_camera_data.matrix * vec4(hit_direction, 0.0)); 
        vec2 prev_pixel_ndc = prev_pixel_homo.xy / prev_pixel_homo.w;
        prev_pixel_ndc.y *= -1;
        vec2 prev_pixel = ndc_to_pixel(prev_pixel_ndc);
        uint prev_pixel_index = pixel_to_index(uvec2(prev_pixel.x, prev_pixel.y));
        if (abs(prev_pixel_ndc.x) <= 1.0 && abs(prev_pixel_ndc.y) <= 1.0) {
            Reservoir previous_reservoir = restir_reservoirs[restir_index_previous].reservoirs[prev_pixel_index];
            uint temporal_seed = random_uint(seed);
            previous_reservoir.num_samples = clamp(previous_reservoir.num_samples, 0, 20 * current_reservoir.num_samples);
            current_reservoir = combine_reservoirs(pixel_index, current_reservoir, previous_reservoir, temporal_seed);       
        }

        // ReSTIR contribution
        if (hit_instance != NULL_INSTANCE) {
            Material material = get_material(hit_instance, hit_uv);

            uint nee_seed =  current_reservoir.sample_seed;
            LightSample light_sample = sample_direct_light(nee_seed, hit_position);

            vec3 normal = hit_normal;

            mat3x3 to_shading_space = transpose(basis(normal));

            vec3 ray_direction = normalize(hit_position - constants.camera_position.xyz);
            vec3 ray_dir_local = normalize(to_shading_space * -ray_direction);
            vec3 light_dir_local = normalize(to_shading_space * light_sample.direction);

            vec3 bsdf_eval = eval_bsdf(light_dir_local, ray_dir_local, material);

            vec3 restir_nee_contribution = bsdf_eval * (light_sample.weight) * current_reservoir.weight * abs(light_dir_local.y);

            vec3 color = image_buffer.data[pixel_index].rgb;
            image_buffer.data[pixel_index] = vec4(color + restir_nee_contribution, 1.0);
            // image_buffer.data[pixel_index] = vec4(length(constants.camera_position.xyz - previous_camera_data.position.xyz) * 10000.0, 0.0, 0.0, 1.0);                       
        }

        restir_reservoirs[restir_index].reservoirs[pixel_index] = current_reservoir;
    }
}